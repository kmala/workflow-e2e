package utils

import (
	"fmt"
	"io"
	"io/ioutil"
	"math/rand"
	neturl "net/url"
	"os"
	"os/exec"
	"path"
	"regexp"
	"runtime"
	"sort"
	"strconv"
	"strings"
	"time"

	"github.com/deis/workflow-e2e/shims"
	. "github.com/onsi/ginkgo"
	. "github.com/onsi/gomega"
	. "github.com/onsi/gomega/gbytes"
	. "github.com/onsi/gomega/gexec"
)

type Cmd struct {
	Env               []string
	CommandLineString string
}

type App struct {
	Name string
	URL  string
}

type Cert struct {
	Name     string
	CertPath string
	KeyPath  string
}

const (
	deisRouterServiceHost = "DEIS_ROUTER_SERVICE_HOST"
	deisRouterServicePort = "DEIS_ROUTER_SERVICE_PORT"
)

var (
	UuidRegExp  = `[0-9a-f]{8}-([0-9a-f]{4}-){3}[0-9a-f]{12}`
	ProcsRegexp = `(%s-v\d+-[\w-]+) up \(v\d+\)`

	errMissingRouterHostEnvVar = fmt.Errorf("missing %s", deisRouterServiceHost)
	DefaultMaxTimeout          = 5 * time.Minute // gomega's default is 2 minutes
	Url                        = getController()
	Debug                      = os.Getenv("DEBUG") != ""
	HomeHome                   = os.Getenv("HOME")
)

//GetRandAppName returns a random app name
func GetRandAppName() string {
	return fmt.Sprintf("test-%d", rand.Intn(999999999))
}

//GetDir gets the root directory
func GetDir() string {
	var _, inDockerContainer = os.LookupEnv("DOCKERIMAGE")
	if inDockerContainer {
		return "/"
	}
	_, filename, _, _ := runtime.Caller(1)
	return path.Dir(filename)
}

// Cancel destroys all the apps of the user and then deletes user account
func Cancel(url, username, password string) {
	// log in to the account
	Login(url, username, password)

	// remove any existing test-* apps
	sess, err := Run("deis apps")
	Expect(err).To(BeNil())
	Eventually(sess).Should(Exit(0))
	re := regexp.MustCompile("test-.*")
	for _, app := range re.FindAll(sess.Out.Contents(), -1) {
		sess, err = Run("deis destroy --app=%s --confirm=%s", app, app)
		Expect(err).To(BeNil())
		Eventually(sess).Should(Say("Destroying %s...", app))
		Eventually(sess).Should(Exit(0))
	}

	// cancel the account
	sess, err = Run("deis auth:cancel --username=%s --password=%s --yes", username, password)
	Expect(err).To(BeNil())
	Eventually(sess).Should(Exit(0))
	Eventually(sess).Should(Say("Account cancelled"))
}

//Login logins a deis user
func Login(url, user, password string) {
	sess, err := Run("deis login %s --username=%s --password=%s", url, user, password)
	Expect(err).To(BeNil())
	Eventually(sess).Should(Exit(0))
	Eventually(sess).Should(Say("Logged in as %s", user))
}

//Logout logouts a deis user
func Logout() {
	sess, err := Run("deis auth:logout")
	Expect(err).To(BeNil())
	Eventually(sess).Should(Exit(0))
	Eventually(sess).Should(Say("Logged out\n"))
}

//Run executes a command and returns the "github.com/onsi/gomega/gexec".Session
func Run(cmdLine string, args ...interface{}) (*Session, error) {
	ourCommand := Cmd{Env: os.Environ(), CommandLineString: fmt.Sprintf(cmdLine, args...)}
	return startCmd(ourCommand)
}

func startCmd(command Cmd) (*Session, error) {
	cmd := exec.Command("/bin/sh", "-c", command.CommandLineString)
	cmd.Env = command.Env
	io.WriteString(GinkgoWriter, fmt.Sprintf("$ %s\n", command.CommandLineString))
	return Start(cmd, GinkgoWriter, GinkgoWriter)
}

func register(url, username, password, email string) {
	sess, err := Run("deis register %s --username=%s --password=%s --email=%s", url, username, password, email)
	Expect(err).To(BeNil())
	Eventually(sess).Should(Say("Registered %s", username))
	Eventually(sess).Should(Say("Logged in as %s", username))
}

//RegisterOrLogin registers a user or does a login if the user already exists
func RegisterOrLogin(url, username, password, email string) {
	sess, err := Run("deis register %s --username=%s --password=%s --email=%s", url, username, password, email)

	Expect(err).To(BeNil())

	sess.Wait()

	if strings.Contains(string(sess.Err.Contents()), "must be unique") {
		// Already registered
		Login(url, username, password)
	} else {
		Eventually(sess).Should(Exit(0))
		Eventually(sess).Should(SatisfyAll(
			Say("Registered %s", username),
			Say("Logged in as %s", username)))
	}
}

// Execute executes the command generated by fmt.Sprintf(cmdLine, args...) and returns its output as a cmdOut structure.
// this structure can then be matched upon using the SucceedWithOutput matcher below
func Execute(cmdLine string, args ...interface{}) (string, error) {
	var cmd *exec.Cmd
	shCommand := fmt.Sprintf(cmdLine, args...)

	if Debug {
		fmt.Println(shCommand)
	}

	cmd = exec.Command("/bin/sh", "-c", shCommand)
	outputBytes, err := cmd.CombinedOutput()

	output := string(outputBytes)

	if Debug {
		fmt.Println(output)
	}

	return output, err
}

//CreateKey creates a ssh key under ~/.ssh/<name> if it doesn't already exist
func CreateKey(name, testHome string) string {
	keyPath := path.Join(testHome, ".ssh", name)
	os.MkdirAll(path.Join(testHome, ".ssh"), 0777)
	// create the key under ~/.ssh/<name> if it doesn't already exist
	if _, err := os.Stat(keyPath); os.IsNotExist(err) {
		sess, err := Run("ssh-keygen -q -t rsa -b 4096 -C %s -f %s -N ''", name, keyPath)
		Expect(err).To(BeNil())
		Eventually(sess).Should(Exit(0))
	}

	os.Chmod(keyPath, 0600)

	return keyPath
}

func getController() string {
	host := os.Getenv(deisRouterServiceHost)
	if host == "" {
		panicStr := fmt.Sprintf(`Set the router host and port for tests, such as:

$ %s=192.0.2.10 %s=31182 make test-integration`, deisRouterServiceHost, deisRouterServicePort)
		panic(panicStr)
	}
	// Make a xip.io URL if DEIS_ROUTER_SERVICE_HOST is an IP V4 address
	ipv4Regex := `^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])$`
	matched, err := regexp.MatchString(ipv4Regex, host)
	if err != nil {
		panic(err)
	}
	if matched {
		host = fmt.Sprintf("deis.%s.xip.io", host)
	}
	port := os.Getenv(deisRouterServicePort)
	switch port {
	case "443":
		return "https://" + host
	case "80", "":
		return "http://" + host
	default:
		return fmt.Sprintf("http://%s:%s", host, port)
	}
}

// GetRawRouter returns the URL to the deis router according to env vars.
//
// Returns an error if the minimal env vars are missing, or there was an error creating a URL from them.
func GetRawRouter() (*neturl.URL, error) {
	host := os.Getenv(deisRouterServiceHost)
	if host == "" {
		return nil, errMissingRouterHostEnvVar
	}
	portStr := os.Getenv(deisRouterServicePort)
	switch portStr {
	case "443":
		return neturl.Parse(fmt.Sprintf("https://%s", host))
	case "80", "":
		return neturl.Parse(fmt.Sprintf("http://%s", host))
	default:
		return neturl.Parse(fmt.Sprintf("http://%s:%s", host, portStr))
	}
}

//CreateApp creates a App with name specified
func CreateApp(name string, options ...string) *Session {
	var noRemote = false
	cmd, err := Run("deis apps:create %s %s", name, strings.Join(options, " "))
	Expect(err).NotTo(HaveOccurred())
	Eventually(cmd).Should(Say("created %s", name))
	Eventually(cmd).Should(Exit(0))

	for _, option := range options {
		if option == "--no-remote" {
			noRemote = true
		}
	}

	if !noRemote {
		Eventually(cmd).Should(Say("Git remote deis added"))
	}
	Eventually(cmd).Should(Say("remote available at "))

	return cmd
}

//DestroyApp deletes the App specified
func DestroyApp(app App) *Session {
	cmd, err := Run("deis apps:destroy --app=%s --confirm=%s", app.Name, app.Name)
	Expect(err).NotTo(HaveOccurred())
	Eventually(cmd, DefaultMaxTimeout).Should(Exit(0))
	Eventually(cmd).Should(SatisfyAll(
		Say("Destroying %s...", app.Name),
		Say(`done in `)))

	return cmd
}

//DeployApp deploys the app onto the cluster
func DeployApp(name, gitSSH string) App {
	app := App{Name: name, URL: strings.Replace(Url, "deis", name, 1)}
	cmd, err := Run("GIT_SSH=%s git push deis master", gitSSH)
	Expect(err).NotTo(HaveOccurred())
	Eventually(cmd.Err, "5m").Should(Say(`Done, %s:v\d deployed to Deis`, app.Name))
	Eventually(cmd).Should(Exit(0))

	return app
}

// CmdWithRetry runs the provided <cmd> repeatedly, once a second up to the
// supplied <timeout> until the <cmd> result contains the <expectedResult>
// An example use of this utility would be curl-ing a url and waiting
// until the response code matches the expected response
func CmdWithRetry(cmd Cmd, expectedResult string, timeout int) bool {
	var result string
	fmt.Printf("Waiting up to %d seconds for `%s` to return %s...\n", timeout, cmd.CommandLineString, expectedResult)
	for i := 0; i < timeout; i++ {
		sess, err := startCmd(cmd)
		Expect(err).NotTo(HaveOccurred())
		result = string(sess.Wait().Out.Contents())
		if strings.Contains(result, expectedResult) {
			return true
		}
		time.Sleep(1 * time.Second)
	}
	fmt.Printf("FAIL: '%s' does not match expected result of '%s'\n", result, expectedResult)
	return false
}

// GitInit simply invokes 'git init' and verifies the command is successful
func GitInit() {
	cmd, err := Run("git init")
	Expect(err).NotTo(HaveOccurred())
	Eventually(cmd).Should(Say("Initialized empty Git repository"))
}

// GitClean destroys the .git directory and verifies the command is successful
func GitClean() {
	cmd, err := Run("rm -rf .git")
	Expect(err).NotTo(HaveOccurred())
	Eventually(cmd).Should(Exit(0))
}

//VerifyAppInfo checks whether the app is properly created
func VerifyAppInfo(testApp App, testUser string) {
	sess, err := Run("deis info -a %s", testApp.Name)
	Expect(err).NotTo(HaveOccurred())
	Eventually(sess).Should(Say("=== %s Application", testApp.Name))
	Eventually(sess).Should(Say(`uuid:\s*%s`, UuidRegExp))
	Eventually(sess).Should(Say(`url:\s*%s`, strings.Replace(testApp.URL, "http://", "", 1)))
	Eventually(sess).Should(Say(`owner:\s*%s`, testUser))
	Eventually(sess).Should(Say(`id:\s*%s`, testApp.Name))

	Eventually(sess).Should(Say("=== %s Processes", testApp.Name))
	Eventually(sess).Should(Say(ProcsRegexp, testApp.Name))

	Eventually(sess).Should(Say("=== %s Domains", testApp.Name))
	Eventually(sess).Should(Say("%s", testApp.Name))
	Eventually(sess).Should(Exit(0))
}

//VerifyAppOpen checks whether the open command works for the deployed app
func VerifyAppOpen(testApp App) {
	// the underlying open utility 'deis open' looks for
	toShim := "open" //darwin
	if runtime.GOOS == "linux" {
		toShim = "xdg-open"
	}
	myShim, err := shims.CreateSystemShim(toShim)
	if err != nil {
		panic(err)
	}
	defer shims.RemoveShim(myShim)

	// create custom env with custom/prefixed PATH value
	env := shims.PrependPath(os.Environ(), myShim.Dir)

	// invoke functionality under test
	sess, err := startCmd(Cmd{Env: env, CommandLineString: "deis open"})
	Expect(err).To(BeNil())
	Eventually(sess).Should(Exit(0))

	// check shim output
	output, err := ioutil.ReadFile(myShim.OutFile.Name())
	Expect(err).NotTo(HaveOccurred())
	Expect(strings.TrimSpace(string(output))).To(Equal(testApp.URL))
}

// CreateBuild invokes deis builds:create <image> -a <app>
// with provided <image> on provided <app>
// and validates that no errors have occurred and build was successful
func CreateBuild(image string, app App, options ...string) {
	pullOrCreateBuild(image, app, "builds:create", strings.Join(options, " "))
}

// DeisPull invokes deis pull <image> -a <app>
// with provided <image> on provided <app>
// and validates that no errors have occurred and build was successful
func DeisPull(image string, app App, options ...string) {
	pullOrCreateBuild(image, app, "pull", strings.Join(options, " "))
}

func pullOrCreateBuild(image string, app App, command string, options string) {
	sess, err := Run("deis %s %s -a %s %s", command, image, app.Name, options)
	Expect(err).To(BeNil())
	Eventually(sess, DefaultMaxTimeout).Should(Exit(0))
	Eventually(sess).Should(Say("Creating build..."))
	Eventually(sess).Should(Say("done"))
}

//AddDomain adds the specified domain to the app
func AddDomain(domain, appName string) {
	addOrRemoveDomain(domain, appName, "add")
}

//RemoveDomain removes the specified domain from the app
func RemoveDomain(domain, appName string) {
	addOrRemoveDomain(domain, appName, "remove")
}

func addOrRemoveDomain(domain, appName, addOrRemove string) {
	// Explicitly build literal substring since 'domain'
	// may be a wildcard domain ('*.foo.com') and we don't want Gomega
	// interpreting this string as a regexp
	var substring string

	sess, err := Run("deis domains:%s %s --app=%s", addOrRemove, domain, appName)
	Expect(err).NotTo(HaveOccurred())
	if addOrRemove == "add" {
		substring = fmt.Sprintf("Adding %s to %s...", domain, appName)
	} else {
		substring = fmt.Sprintf("Removing %s from %s...", domain, appName)
	}
	Eventually(sess.Wait().Out.Contents()).Should(ContainSubstring(substring))
	Eventually(sess).Should(Say("done"))
	Eventually(sess).Should(Exit(0))
}

//ListProcs lists all the process for the specified app
func ListProcs(testApp App) *Session {
	sess, err := Run("deis ps:list --app=%s", testApp.Name)
	Expect(err).NotTo(HaveOccurred())
	Eventually(sess).Should(Say("=== %s Processes", testApp.Name))
	Eventually(sess).Should(Exit(0))
	return sess
}

// ScrapeProcs returns the sorted process names for an app from the given output.
// It matches the current "deis ps" output for a healthy container:
//   earthy-vocalist-v2-cmd-1d73e up (v2)
//   myapp-v16-web-bujlq up (v16)
func ScrapeProcs(app string, output []byte) []string {
	re := regexp.MustCompile(fmt.Sprintf(ProcsRegexp, app))
	found := re.FindAllSubmatch(output, -1)
	procs := make([]string, len(found))
	for i := range found {
		procs[i] = string(found[i][1])
	}
	sort.Strings(procs)
	return procs
}

//ListCerts lists all the certificates
func ListCerts() *Session {
	sess, err := Run("deis certs:list")
	Expect(err).NotTo(HaveOccurred())
	Eventually(sess).Should(Exit(0))

	return sess
}

//RemoveCerts is used to remove a certificate from the platform
func RemoveCerts(certs []string) {
	for _, cert := range certs {
		sess, err := Run("deis certs:remove %s", cert)
		Expect(err).NotTo(HaveOccurred())
		Eventually(sess).Should(Say("Removing %s...", cert))
		Eventually(sess).Should(Say("done"))
		Eventually(sess).Should(Exit(0))
	}

	Eventually(ListCerts()).Should(Say("No certs"))
}

//AddCert is used to add a certificate to the platform
func AddCert(certName, cert, key string) {
	sess, err := Run("deis certs:add %s %s %s", certName, cert, key)
	Expect(err).NotTo(HaveOccurred())
	Eventually(sess).Should(Say("Adding SSL endpoint..."))
	Eventually(sess).Should(Say("done"))
	Eventually(sess).Should(Exit(0))

	Eventually(ListCerts().Wait().Out.Contents()).Should(ContainSubstring(certName))
}

//AttachCert is used to attach a certificate to the domain
func AttachCert(certName, domain string) {
	attachOrDetachCert(certName, domain, "attach")
}

//DetachCert is used to remove a certificate from the domain
func DetachCert(certName, domain string) {
	attachOrDetachCert(certName, domain, "detach")
}

func attachOrDetachCert(certName, domain, attachOrDetach string) {
	// Explicitly build literal substring since 'domain'
	// may be a wildcard domain ('*.foo.com') and we don't want Gomega
	// interpreting this string as a regexp
	var substring string

	sess, err := Run("deis certs:%s %s %s", attachOrDetach, certName, domain)
	Expect(err).NotTo(HaveOccurred())
	if attachOrDetach == "attach" {
		substring = fmt.Sprintf("Attaching certificate %s to domain %s...", certName, domain)
	} else {
		substring = fmt.Sprintf("Detaching certificate %s from domain %s...", certName, domain)
	}
	Eventually(sess.Wait().Out.Contents()).Should(ContainSubstring(substring))
	Eventually(sess).Should(Say("done"))
	Eventually(sess).Should(Exit(0))
}

//CertsInfo gives the detials of the specified certificate
func CertsInfo(certName string) *Session {
	sess, err := Run("deis certs:info %s", certName)
	Expect(err).NotTo(HaveOccurred())
	Eventually(sess).Should(Say("=== %s Certificate", certName))
	Eventually(sess).Should(Exit(0))

	return sess
}

//VerifySSLEndpoint checks whether the given endpoint is active or not
func VerifySSLEndpoint(customSSLEndpoint, domain string, expectedStatusCode int) {
	maxRetryIterations := 15                         // ~1 iteration per second
	domain = strings.Replace(domain, "*", "blah", 1) // replace asterix if wildcard domain
	curlCmd := Cmd{CommandLineString: fmt.Sprintf(`curl -k -H "Host: %s" -sL -w "%%{http_code}\\n" "%s" -o /dev/null`, domain, customSSLEndpoint)}
	Eventually(CmdWithRetry(curlCmd, strconv.Itoa(expectedStatusCode), maxRetryIterations)).Should(BeTrue())
}
